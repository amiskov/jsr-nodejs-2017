# Занятие №1, 28 апреля

## Инструменты
### Нода
На курсе нужна версия `7.8` или выше.

### Редактор
Юзает Атом.

### Линтеры
Про [ESLint](http://eslint.org) рассказывал.

Есть [гуглевый конфиг](https://github.com/google/eslint-config-google). Надо изучить.

[Конфиг AirBNB](https://github.com/airbnb/javascript).

Нормально, когда разработчик работает на разных проектах с разными конфигами. Плохо, когда их вообще нет.

### ES6 в Ноде
http://node.green — тут есть.

Говорит, что поддержка ES6 достаточная. Больше всего хотят импортов, но это не так уж и нужно.

### NPM
`npm repo eslint` — откроет в браузере страницу репозитория модуля, чтоб не гуглить его.

`npm home eslint` — откроет домашний сайт, eslint.org.

Это не единственный пакетный менеджер. Есть [Yarn](https://yarnpkg.com). Советует попробовать, но не прям с них много работал. В целом норм, реально есть профиты, развивается, есть сервисы с ним.

## Сервер на Ноде, особенности
Браузер минуты через 2 закрывает соединение по таймауту, если сервер не отвечает.

А сервер на Ноде не будет отвечать, если мы этого руками не напишем.

Сервер на Ноде весьма низкоуровневый по сравнению с другими разными технологиями, языками, фреймворками. Нода сама ничего не делает, надо все делать руками.

Передача функции в конструктор `http.Server` — автоматическая подписка на реквест. То же самое, что использование метода `.on` на его объектах:

```js
const {Server} = require('http');

// Это:
const server = new Server((req, res) => {});

// Аналогично этому:
const server2 = new Server();
server2.on('request', (req, res) => {});
```

### События при запросе к серверу из браузера
`http.Server` наследует от `net.Server`, а у него еще свои события. Поэтому в доках не вся картина. Чтобы увидеть все события, которые происходят при работе сервера, можно переопределить метод emit, добавив вывод в консоль:

```js
const emit = server.emit;
server.emit = (...args) => {
    console.log(args[0]);
    return emit.apply(server, args);
};
```

Можно видеть 2 реквеста при одном запросе. Второй – это фавикон, браузер пытается ее запросить по умолчанию. А `connection` — один. Потому что `Keep-Alive`. `Keep-Alive` — заголовок, который позволяет клиенту и серверу поддерживать одно [постоянное соединение](https://ru.wikipedia.org/wiki/Постоянное_HTTP-соединение) для передачи данных:

![](keep_alive_persistent_connection.svg)

Современные браузеры по умолчанию его ставят.

В Ноде процесс живет и между запросами можно, например, увеличивать переменную:

```js
import {Server} from 'http';

const server = new Server();

let i = 0;

server.on('request', (req, res) => {
    // Счетчик будет увеличиваться
    ++i;
    res.end(i.toString());
});

server.listen(3000);
```

Отправить пользователю данные через `res.end(...)` мы можем только строку или `Buffer`.

## Модули Ноды
Сначала Нода ищет модули внутри себя (системные, core modules).
Потом в папках `node_modules`.
Потом смотрит, установлена ли `NODE_PATH` и если установлена, то ище в соответствующих директориях. Пример установки:

```bash
NODE_PATH=.:./modules:./lib node server-counter.js
```

`:` — разделитель путей.

## Автоапдейт
[`nodemon`](https://www.npmjs.com/package/nodemon) — устанавливаем глобально, запускаем и он позволяет не перезапускать сервер при изменении.

## Дебаг
Через WebStorm. Только не всегда успевает за развитием. 

[`node-inspector`](https://github.com/node-inspector/node-inspector) через Chrome Dev Tools. Работает так себе на практике.

С версии 6.3 Нода встроила `node --inspect` в свою поставку. Так хорошо пошел `node-inspector` в народе.

Самый клевый вариант — встроенный в Ноду [`node --inspect`](https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27).

## Event Loop, очередь
Позволяет в цикле V8 и в одном процессе Ноды выполнять одновременно много асинхронных операций.

Сердце Ноды:
* V8 — JS-машина, разработан в Google, используется в Хроме.
* libUV — отвечает за системные операции (I/O), на уровне ОС.

Событийный цикл регулирует, как между собой взаимодействуют V8 и libUV. Это лучше всего видно на асинхронных операциях.

При обработке кода сначала выполняется то, что может сделать V8 сам (чистый JS, вычисления), а уже потом асинхронные операции с libUV:
* микротаски — что делает V8 сам (синхронный JS, `process.nextTick`, промисы)
* макротаски — то, что требует задействования libUV.

`nextTick` — прадедушка `Promise.resolve`. Такой же JS, только в Ноде. Но все `nextTick` всегда будет выполнен раньше промисов. Если их несколько, то в порядке появления в коде.

`setImmediate` — вроде как выполнить немедленно. Но `process.nextTick` происходить еще более "немедленно". Немного запутывает.

### Зачем нужен `nextTick`?
Чтобы функция была по-настоящему асинхронной, даже если вернет ошибку. Пример:

```js
const fx = (param, cb) => {
    // ожидаем, что cb должен быть запущен после текущего JS (который вне колбэков)
    if(param <= 10) {
        // Так cb вызовется после текущего JS
        process.nextTick(cb(new Error('Must be > 10')));
        
        //cb(new Error('Must be > 10');  // а так был бы до, если ошибка
    }
    
    setTimeout(cb, 1000); // асинхронный вызов cb
};

fx(() => console.log()); // ожидаем, что функция-параметр (cb) будет вызвана после текущего JS

console.log(1 + 2); // текущий JS
```

## Работа или завершение процесса
Если в процессе имеются объекты, которые выполняют работу или могут ее выполнить (слушают порт, таймер), то процесс живет. Если таких объектов не осталось, то процесс завершается.

Иногда нужно запускать таймеры, слушателей, которые не являются основными в программе и нужны только пока работаеют основные объекты.

Метод `unref` позволяет сказать процессу, что какие-то объекты не являются основными и их не надо ждать, чтобы завершить процесс:

```js
const timer = setTimeout(() => {
    console.log('done');
}, 1000);
// timer.unref(); // так таймер сразу же отключится, если никакие другие объекты не выполняют работу
```

## Безопасное завершение соединения
Браузеры держат `Keep-Alive` некоторое время даже когда ничего не отправляют и не получают. Открыта таба — он держится некоторое время. И даже после закрытия табы коннекшен может держаться (а вдруг юзер нажмет `Cmd+T`). И даже между табами может шарится коннекшен.

Как завершить соединение безопасно, чтобы пользователь не потерял данные (graceful shutdown)?

Мы можем вручную следить за каждым коннекшеном и определить, активный он или нет. Каждый реквест помечаем как активный, а когда он начинает простаивать, то помечать его как не активный. И если понадобится остановить сервер, то такие коннекшены мы сможем закрыть без зазрения совести.

`req.socket` — объект соединения.

